<!DOCTYPE html><html><head><meta charset="utf-8"><title>nss tech note5 - Mozilla | MDN</title></head><body><main><article class="main-page-content" lang="en-US"><h1>nss tech note5</h1><h2 id="using_nss_to_perform_miscellaneous_cryptographic_operations"><a href="#using_nss_to_perform_miscellaneous_cryptographic_operations" title="Permalink to Using NSS to perform miscellaneous cryptographic operations">Using NSS to perform miscellaneous cryptographic operations</a></h2><div></div><h3 id="nss_technical_note_5"><a href="#nss_technical_note_5" title="Permalink to NSS Technical Note: 5">NSS Technical Note: 5</a></h3><div><ul>
  <li>NSS Project Info is at <a href="https://www.mozilla.org/projects/security/pki/nss/" class="external" rel=" noopener">http://www.mozilla.org/projects/security/pki/nss/</a></li>
  <li>You can browse the NSS source online at <a href="http://lxr.mozilla.org/mozilla/source/security/nss/" class="external" rel=" noopener">http://lxr.mozilla.org/mozilla/source/security/nss/</a> &nbsp;and <a href="http://lxr.mozilla.org/security/" class="external" rel=" noopener">http://lxr.mozilla.org/security/</a></li>
  <li>Be sure to look for <a href="/NSS/NSS_Sample_Code" data-flaw="link1">sample code</a> first for things you need to do.</li>
  <li><b>Note: </b>This document contains code snippets that focus on essential aspects of the task and often do not illustrate all the cleanup that needs to be done. Also, this document does not attempt to be an exhaustive survey of all possible ways to do a certain task; it merely tries to show a certain way.</li>
</ul>
<hr></div><h2 id="encryptdecrypt"><a href="#encryptdecrypt" title="Permalink to Encrypt/Decrypt">Encrypt/Decrypt</a></h2><div><ol>
  <li>Include headers<br>
    <small><i>#include "nss.h"<br>
    #include "pk11pub.h"</i></small></li>
  <li>Make sure NSS is initialized.The simplest Init function, in case you don't need a NSS database is<br>
    <small><i>NSS_NoDB_Init(".")</i></small></li>
  <li>Choose a cipher mechanism. Note that some mechanisms (*_PAD) imply the padding is handled for you by NSS. If you choose something else, then data padding is the application's responsibility. You can find a list of cipher mechanisms in security/nss/lib/softoken/pkcs11.c - grep for CKF_EN_DE_.<br>
    <small><i>CK_MECHANISM_TYPE cipherMech = CKM_DES_CBC_PAD </i>&lt;big&gt;(for example)&lt;/big&gt;</small></li>
  <li>Choose a slot on which to do the operation<br>
    <small><i>PK11SlotInfo* slot = PK11_GetBestSlot(cipherMech, NULL); &nbsp; <b>OR</b><br>
    PK11SlotInfo* slot = PK11_GetInternalKeySlot(); /* alwys returns internal slot, may not be optimal */</i></small></li>
  <li>Prepare the Key
    <ul>
      <li>If using a raw key<br>
        <small><i>/* turn the raw key into a SECItem */<br>
        SECItem keyItem;<br>
        keyItem.data = /* ptr to an array of key bytes */<br>
        keyItem.len = /* length of the array of key bytes */<br>
        <br>
        /* turn the SECItem into a key object */<br>
        PK11SymKey* SymKey = PK11_ImportSymKey(slot, cipherMech, PK11_OriginUnwrap,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CKA_ENCRYPT, &amp;keyItem, NULL)</i></small>;</li>
      <li>If generating the key - see section <a href="#generate_a_symmetric_key">Generate a Symmetric Key</a><br>
        &nbsp;</li>
    </ul>
  </li>
  <li><small>&lt;big&gt;Prepare the parameter for crypto context. IV is relevant only when using CBC mode of encryption. If not using CBC mode, just pass a NULL IV parm to PK11_ParamFromIV function<br>
    <small><i>SECItem ivItem;<br>
    ivItem.data = /* ptr to an array of IV bytes */<br>
    ivItem.len = /* length of the array of IV bytes */<br>
    SECItem *SecParam = PK11_ParamFromIV(cipherMech, &amp;ivItem);</i></small>&lt;/big&gt;</small></li>
  <li><small>&lt;big&gt;Now encrypt and decrypt using the key and parameter setup in above steps&lt;/big&gt;</small>
    <ul>
      <li>Create Encryption context<br>
        <small><i>PK11Context* EncContext = PK11_CreateContextBySymKey(cipherMech,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CKA_ENCRYPT or CKA_DECRYPT,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SymKey, SecParam);</i></small></li>
      <li>Do the Operation. If encrypting, outbuf len must be atleast (inbuflen + blocksize). If decrypting, outbuflen must be atleast inbuflen.<br>
        <small><i>SECStatus s = PK11_CipherOp(EncContext, outbuf, &amp;tmp1_outlen, sizeof outbuf, inbuf,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;inbuflen);<br>
        s = PK11_DigestFinal(EncContext, outbuf+tmp1_outlen, &amp;tmp2_outlen,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;sizeof outbuf - tmp1_outlen);<br>
        result_len = tmp1_outlen + tmp2_outlen;</i></small></li>
      <li><small>&lt;big&gt;Destroy the Context<br>
        <small><i>PK11_DestroyContext(EncContext, PR_TRUE);</i></small>&lt;/big&gt;</small></li>
    </ul>
  </li>
  <li><small>&lt;big&gt;Repeat Step 6 <b>any number of times</b>. When all done with encrypt/decrypt ops, clean up&lt;/big&gt;</small><br>
    <small>&lt;big&gt;<small><i>PK11_FreeSymKey(SymKey);<br>
    SECITEM_FreeItem(SecParam, PR_TRUE);<br>
    PK11_FreeSlot(slot);</i></small>&lt;/big&gt;</small></li>
</ol>
<p><b>Note: </b>AES encryption, a fixed blocksize of 16 bytes is used. The Rijndael algorithm permits 3 blocksizes (16, 24, 32 bytes), but the AES standard requires the blocksize to be 16 bytes. The keysize can vary and these keysizes are permitted: 16, 24, 32 bytes.<br>
  <br>
  You can also look at a <a href="../sample-code/sample2.html">sample program</a> illustrating encryption</p>
<hr></div><h2 id="hash_digest"><a href="#hash_digest" title="Permalink to Hash / Digest">Hash / Digest</a></h2><div><ol>
  <li>Include headers<br>
    <small><i>#include "nss.h"<br>
    #include "pk11pub.h"</i></small></li>
  <li>Make sure NSS is initialized.The simplest Init function, in case you don't need a NSS database is<br>
    <small><i>NSS_NoDB_Init(".")</i></small></li>
  <li><small>&lt;big&gt;Create Digest context&lt;/big&gt;</small>. Some of the digest algorithm identifiers are (without the SEC_OID_ prefix) : MD2, MD5, SHA1, SHA256, SHA384, SHA512.<br>
    <small><i>PK11Context* DigestContext = PK11_CreateDigestContext(SEC_OID_MD5);</i></small></li>
  <li><small>&lt;big&gt;Digest the data&lt;/big&gt;</small><br>
    <small>&lt;big&gt;<small><i>SECStatus s = PK11_DigestBegin(DigestContext);<br>
    s = PK11_DigestOp(DigestContext, data, sizeof data);<br>
    s = PK11_DigestFinal(DigestContext, digest, &amp;len, sizeof digest);<br>
    /* now, digest contains the 'digest', and len contains the length of the digest */</i></small>&lt;/big&gt;</small></li>
  <li>Clean up<br>
    <small><i>PK11_DestroyContext(DigestContext, PR_TRUE);</i></small></li>
</ol>
<p><br>
  You can also look at a <a href="../sample-code/sample3.html">sample program</a> illustrating this</p>
<hr></div><h2 id="hash_digest_with_secret_key_included"><a href="#hash_digest_with_secret_key_included" title="Permalink to Hash / Digest with secret key included">Hash / Digest with secret key included</a></h2><div><ol>
  <li>Include headers<br>
    <small><i>#include "nss.h"<br>
    #include "pk11pub.h"</i></small></li>
  <li>Make sure NSS is initialized.The simplest Init function, in case you don't need a NSS database is<br>
    <small><i>NSS_NoDB_Init(".")</i></small></li>
  <li>Choose a digest mechanism. You can find a list of digest mechanisms in security/nss/lib/softoken/pkcs11.c - grep for CKF_DIGEST.<br>
    <small><i>CK_MECHANISM_TYPE digestMech = CKM_MD5 </i>&lt;big&gt;(for example)&lt;/big&gt;</small></li>
  <li>Choose a slot on which to do the operation<br>
    <small><i>PK11SlotInfo* slot = PK11_GetBestSlot(digestMech, NULL); &nbsp; <b>OR</b><br>
    PK11SlotInfo* slot = PK11_GetInternalKeySlot(); /* always returns int slot, may not be optimal */</i></small></li>
  <li>Prepare the Key
    <ul>
      <li>If using a raw key<br>
        <small><i>/* turn the raw key into a SECItem */<br>
        SECItem keyItem;<br>
        keyItem.data = /* ptr to an array of key bytes */<br>
        keyItem.len = /* length of the array of key bytes */<br>
        <br>
        /* turn the SECItem into a key object */<br>
        PK11SymKey* SymKey = PK11_ImportSymKey(slot, digestMech, PK11_OriginUnwrap,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CKA_DIGEST, &amp;keyItem, NULL)</i></small>;</li>
      <li>If generating the key - see section <a href="#generate_a_symmetric_key">Generate a Symmetric Key</a>. Can use <small><i>CKM_GENERIC_SECRET_KEY_GEN </i></small>as the key gen mechanism.<br>
        &nbsp;</li>
    </ul>
  </li>
  <li><small>&lt;big&gt;Prepare the parameter for crypto context. The param must be provided, but can be empty.<br>
    <small><i>SECItem param;<br>
    param.data = 0;<br>
    param.len = 0;</i></small>&lt;/big&gt;</small></li>
  <li><small>&lt;big&gt;Create Crypto context&lt;/big&gt;</small><br>
    <small><i>PK11Context* DigestContext = PK11_CreateContextBySymKey(digestMech, CKA_DIGEST, SymKey,<br>
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;param);</i></small></li>
  <li><small>&lt;big&gt;Digest the data&lt;/big&gt;</small>, providing the key<br>
    <small>&lt;big&gt;<small><i>SECStatus s = PK11_DigestBegin(DigestContext);<br>
    s = PK11_DigestKey(DigestContext, SymKey);<br>
    s = PK11_DigestOp(DigestContext, data, sizeof data);<br>
    s = PK11_DigestFinal(DigestContext, digest, &amp;len, sizeof digest);<br>
    /* now, digest contains the 'digest', and len contains the length of the digest */</i></small>&lt;/big&gt;</small></li>
  <li>Clean up<br>
    <small><i>PK11_DestroyContext(DigestContext, PR_TRUE);<br>
    PK11_FreeSymKey(SymKey);<br>
    PK11_FreeSlot(slot);</i></small></li>
</ol>
<p>You can also look at a <a href="../sample-code/sample3.html">sample program</a> illustrating this</p>
<hr></div><h2 id="hmac"><a href="#hmac" title="Permalink to HMAC">HMAC</a></h2><div><ol>
  <li>Include headers<br>
    <small><i>#include "nss.h"<br>
    #include "pk11pub.h"</i></small></li>
  <li>Make sure NSS is initialized.The simplest Init function, in case you don't need a NSS database is<br>
    <small><i>NSS_NoDB_Init(".")</i></small></li>
  <li>Choose a&nbsp; HMAC mechanism. You can find a list of HMAC mechanisms in security/nss/lib/softoken/pkcs11.c - grep for CKF_SN_VR, and choose the mechanisms that contain HMAC in the name<br>
    <small><i>CK_MECHANISM_TYPE hmacMech = CKM_MD5_HMAC; </i>&lt;big&gt;(for example)&lt;/big&gt;</small></li>
  <li>Choose a slot on which to do the operation<br>
    <small><i>PK11SlotInfo* slot = PK11_GetBestSlot(hmacMech, NULL); &nbsp; <b>OR</b><br>
    PK11SlotInfo* slot = PK11_GetInternalKeySlot(); /* always returns int slot, may not be optimal */</i></small></li>
  <li>Prepare the Key
    <ul>
      <li>If using a raw key<br>
        <small><i>/* turn the raw key into a SECItem */<br>
        SECItem keyItem;<br>
        keyItem.type = siBuffer;<br>
        keyItem.data = /* ptr to an array of key bytes */<br>
        keyItem.len = /* length of the array of key bytes */<br>
        <br>
        /* turn the SECItem into a key object */<br>
        PK11SymKey* SymKey = PK11_ImportSymKey(slot, hmacMech, PK11_OriginUnwrap,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CKA_SIGN,&nbsp; &amp;keyItem, NULL)</i></small>;</li>
      <li>If generating the key - see section <a href="#generate_a_symmetric_key">Generate a Symmetric Key</a>. Can use <small><i>CKM_GENERIC_SECRET_KEY_GEN </i></small>as the key gen mechanism.<br>
        &nbsp;</li>
    </ul>
  </li>
  <li><small>&lt;big&gt;Prepare the parameter for crypto context. The param must be provided, but can be empty.<br>
    <small><i>SECItem param;<br>
    param.type = siBuffer;<br>
    param.data = NULL;<br>
    param.len = 0;</i></small>&lt;/big&gt;</small></li>
  <li><small>&lt;big&gt;Create Crypto context&lt;/big&gt;</small><br>
    <small><i>PK11Context* DigestContext = PK11_CreateContextBySymKey(hmacMech, CKA_SIGN,<br>
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SymKey, &amp;param);</i></small></li>
  <li><small>&lt;big&gt;Digest the data&lt;/big&gt;</small><br>
    <small>&lt;big&gt;<small><i>SECStatus s = PK11_DigestBegin(DigestContext);<br>
    s = PK11_DigestOp(DigestContext, data, sizeof data);<br>
    s = PK11_DigestFinal(DigestContext, digest, &amp;len, sizeof digest);<br>
    /* now, digest contains the 'signed digest', and len contains the length of the digest */</i></small>&lt;/big&gt;</small></li>
  <li>Clean up<br>
    <small><i>PK11_DestroyContext(DigestContext, PR_TRUE);</i></small><br>
    <small><i>PK11_FreeSymKey(SymKey);<br>
    PK11_FreeSlot(slot);</i></small></li>
</ol>
<p><br>
  You can also look at a <a href="../sample-code/sample3.html">sample program</a> illustrating this</p>
<hr></div><h2 id="symmetric_key_wrappingunwrapping_of_a_symmetric_key"><a href="#symmetric_key_wrappingunwrapping_of_a_symmetric_key" title="Permalink to Symmetric Key Wrapping/Unwrapping of a Symmetric Key">Symmetric Key Wrapping/Unwrapping of a Symmetric Key</a></h2><div><ol>
  <li>Include headers<br>
    <small><i>#include "nss.h"<br>
    #include "pk11pub.h"</i></small></li>
  <li>Make sure NSS is initialized.The simplest Init function, in case you don't need a NSS database is<br>
    <small><i>NSS_NoDB_Init(".")</i></small></li>
  <li>Choose a&nbsp; Wrapping mechanism. See wrapMechanismList in security/nss/lib/pk11wrap/pk11slot.c and security/nss/lib/ssl/ssl3con.c for examples of wrapping mechanisms. Most of them are cipher mechanisms.<br>
    <small><i>CK_MECHANISM_TYPE wrapMech = CKM_DES3_ECB; </i>&lt;big&gt;(for example)&lt;/big&gt;</small></li>
  <li>Choose a slot on which to do the operation<br>
    <small><i>PK11SlotInfo* slot = PK11_GetBestSlot(wrapMech, NULL); &nbsp; <b>OR</b><br>
    PK11SlotInfo* slot = PK11_GetInternalKeySlot(); /* always returns int slot, may not be optimal */</i><br>
    <br>
    &lt;big&gt;Regarding the choice of slot and wrapMech, if you know one, you can derive the other. You can get the best slot given a wrap mechanism (as shown above), or get the best wrap mechanism given a slot using:&lt;/big&gt;</small><br>
    <small><i>CK_MECHANISM_TYPE wrapMech = PK11_GetBestWrapMechanism(slot)</i></small></li>
  <li>Prepare the Wrapping Key
    <ul>
      <li>If using a raw key<br>
        <small><i>/* turn the raw key into a SECItem */<br>
        SECItem keyItem;<br>
        keyItem.data = /* ptr to an array of key bytes */<br>
        keyItem.len = /* length of the array of key bytes */<br>
        <br>
        /* turn the SECItem into a key object */<br>
        PK11SymKey* WrappingSymKey = PK11_ImportSymKey(slot, wrapMech,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PK11_OriginUnwrap,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CKA_WRAP,&nbsp; &amp;keyItem, NULL)</i></small><br>
        &nbsp;</li>
      <li>If generating the key - see section <a href="#generate_a_symmetric_key">Generate a Symmetric Key</a><br>
        &nbsp;</li>
    </ul>
  </li>
  <li>Prepare the To-be-Wrapped Key
    <ul>
      <li>If using a raw key<br>
        <small><i>/* turn the raw key into a SECItem */<br>
        SECItem keyItem;<br>
        keyItem.data = /* ptr to an array of key bytes */<br>
        keyItem.len = /* length of the array of key bytes */<br>
        <br>
        /* turn the SECItem into a key object */<br>
        PK11SymKey* ToBeWrappedSymKey = PK11_ImportSymKey(slot, wrapMech,,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PK11_OriginUnwrap,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;CKA_WRAP,&nbsp; &amp;keyItem, NULL)</i></small>;</li>
      <li>If generating the key - see section <a href="#generate_a_symmetric_key">Generate a Symmetric Key</a><br>
        &nbsp;</li>
    </ul>
  </li>
  <li><small>&lt;big&gt;Prepare the parameter for crypto context. IV is relevant only when using CBC cipher mode. If not using CBC mode, just pass a NULL <i>SecParam </i>to <i>PK11_WrapSymKey </i>or<i> PK11_UnwrapSymKey </i>function<br>
    <small><i>SECItem ivItem;<br>
    ivItem.data = /* ptr to an array of IV bytes */<br>
    ivItem.len = /* length of the array of IV bytes */<br>
    SECItem *SecParam = PK11_ParamFromIV(wrapMech, &amp;ivItem);</i></small>&lt;/big&gt;</small></li>
  <li>Allocate space for the wrapped key<br>
    <small><i>SECItem WrappedKey;<br>
    WrappedKey.len = SOME_LEN;<br>
    WrappedKey.data = allocate (SOME_LEN) bytes;</i></small></li>
  <li><small>&lt;big&gt;Do the Wrap&lt;/big&gt;</small>. Note that the WrappingSymKey and the ToBeWrappedSymKey must be on the slot where the wrap is going to happen. To move &nbsp;keys to the desired slot, see section <a href="#moving_a_key_from_one_slot_to_another">Moving a Key from one slot to another</a><br>
    <small>&lt;big&gt;<small><i>SECStatus s = PK11_WrapSymKey(wrapMech, SecParam, WrappingSymKey,<br>
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ToBeWrappedSymKey, &amp;WrappedKey);</i></small>&lt;/big&gt;</small></li>
  <li><small>&lt;big&gt;<small>&lt;big&gt;Transport/Store or do whatever with the Wrapped Key (WrappedKey.data, WrappedKey.len)&lt;/big&gt;</small>&lt;/big&gt;</small></li>
  <li><small>&lt;big&gt;<small>&lt;big&gt;Unwrapping.&nbsp;&lt;/big&gt;</small>&lt;/big&gt;</small>
    <ul>
      <li><small>&lt;big&gt;<small>&lt;big&gt;Set up the args to the function <small><i>PK11_UnwrapSymKey</i></small>, most of which are illustrated above. The <small><i>keyTypeMech </i></small>arg of type <small><i>CK_MECHANISM_TYPE &nbsp;</i>&lt;big&gt;indicates the type of key that was wrapped and can be same as the <small><i>wrapMech </i></small>(e.g. <i><small>wrapMech=CKM_SKIPJACK_WRAP, keyTypeMech=CKM_SKIPJACK_CBC64; wrapMech=CKM_SKIPJACK_CBC64, keyTypeMech=CKM_SKIPJACK_CBC64</small></i>).&lt;/big&gt;</small>&lt;/big&gt;</small>&lt;/big&gt;</small></li>
      <li>Do the unwrap<br>
        <small>&lt;big&gt;<small>&lt;big&gt;<small><i>PK11SymKey* UnwrappedSymKey = PK11_UnwrapSymKey(WrappingSymKey,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wrapMech</i></small>&lt;/big&gt;</small>&lt;/big&gt;</small><small>&lt;big&gt;<small>&lt;big&gt;<small><i>, SecParam, &amp;WrappedKey,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; keyTypeMech,</i></small>&lt;/big&gt;</small>&lt;/big&gt;</small><br>
        <small>&lt;big&gt;<small>&lt;big&gt;<small><i>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CKA_UNWRAP, /* or CKA_DECRYPT? */<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;size_of_key_that_was_wrapped_bytes);</i></small>&lt;/big&gt;</small>&lt;/big&gt;</small></li>
    </ul>
  </li>
  <li>Clean up<br>
    <small><i>PK11_FreeSymKey(WrappingSymKey);</i></small><br>
    <i><small>PK11_FreeSymKey(ToBeWrappedSymKey);<br>
    PK11_FreeSymKey(UnwrappedSymKey);<br>
    if (SecParam) SECITEM_FreeItem(SecParam, PR_TRUE);</small><br>
    <small>SECITEM_FreeItem(&amp;WrappedKey, PR_TRUE);</small><br>
    <small>PK11_FreeSlot(slot);</small>&nbsp;</i></li>
</ol>
<hr></div><h2 id="symmetric_key_wrappingunwrapping_of_a_private_key"><a href="#symmetric_key_wrappingunwrapping_of_a_private_key" title="Permalink to Symmetric Key Wrapping/Unwrapping of a Private Key">Symmetric Key Wrapping/Unwrapping of a Private Key</a></h2><div><ol>
  <li>Include headers<br>
    <small><i>#include "nss.h"<br>
    #include "pk11pub.h"</i></small></li>
  <li>Make sure NSS is initialized.</li>
  <li>Choose a&nbsp; Wrapping mechanism. See wrapMechanismList in security/nss/lib/pk11wrap/pk11slot.c and security/nss/lib/ssl/ssl3con.c for examples of wrapping mechanisms. Most of them are cipher mechanisms.<br>
    <small><i>CK_MECHANISM_TYPE wrapMech = CKM_DES3_ECB; </i>&lt;big&gt;(for example).&lt;/big&gt;</small></li>
  <li>Slot on which to do the operation<br>
    <small><i>PK11SlotInfo* slot = PK11_GetBestSlot(wrapMech, NULL); &nbsp; <b>OR</b><br>
    PK11SlotInfo* slot = PK11_GetInternalKeySlot(); /* always returns int slot, may not be optimal */</i></small><br>
    This should be the slot that is best suited for the wrapping. This may or may not be the slot that contains the private key or the slot that contains the Symmetric key.<br>
    <br>
    <small>&lt;big&gt;Regarding the choice of slot and wrapMech, if you know one, you can derive the other. You can get the best slot given a wrap mechanism (as shown above), or get the best wrap mechanism given a slot using:&lt;/big&gt;</small><br>
    <small><i>CK_MECHANISM_TYPE wrapMech = PK11_GetBestWrapMechanism(slot)</i></small></li>
  <li>Prepare the Wrapping Key
    <ul>
      <li>If using a raw key<br>
        <small><i>/* turn the raw key into a SECItem */<br>
        SECItem keyItem;<br>
        keyItem.data = /* ptr to an array of key bytes */<br>
        keyItem.len = /* length of the array of key bytes */<br>
        <br>
        /* turn the SECItem into a key object */<br>
        PK11SymKey* WrappingSymKey = PK11_ImportSymKey(slot, wrapMech,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PK11_OriginUnwrap,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CKA_WRAP,&nbsp; &amp;keyItem, NULL)</i></small>;</li>
      <li>If generating the key - see section <a href="#generate_a_symmetric_key">Generate a Symmetric Key</a><br>
        &nbsp;</li>
    </ul>
  </li>
  <li>Prepare the To-be-Wrapped Key
    <ul>
      <li><small><i>SECKEYPrivateKey *ToBeWrappedPrivKey&nbsp;</i></small></li>
    </ul>
  </li>
  <li><small>&lt;big&gt;Prepare the parameter for crypto context. IV is relevant only when using CBC cipher mode. If not using CBC mode, just pass a NULL <i>SecParam </i>to <i>PK11_WrapPrivKey </i>function<br>
    <small><i>SECItem ivItem;<br>
    ivItem.data = /* ptr to an array of IV bytes */<br>
    ivItem.len = /* length of the array of IV bytes */<br>
    SECItem *SecParam = PK11_ParamFromIV(wrapMech, &amp;ivItem);</i></small>&lt;/big&gt;</small></li>
  <li>Allocate space for the wrapped key. Note that a 2048-bit <i>wrapped </i>RSA private key takes up around 1200 bytes.<br>
    <small><i>SECItem WrappedKey;<br>
    WrappedKey.len = SOME_LEN;<br>
    WrappedKey.data = allocate (SOME_LEN) bytes;</i></small></li>
  <li><small>&lt;big&gt;Do the Wrap&lt;/big&gt;</small>. Note that the WrappingSymKey and the ToBeWrappedPvtKey must be on the slot where the wrap is going to happen. To move &nbsp;keys to the desired slot, see section <a href="#moving_a_key_from_one_slot_to_another">Moving a Key from one slot to another</a><br>
    <small>&lt;big&gt;<small><i>SECStatus s = PK11_WrapPrivKey(slot, WrappingSymKey,&nbsp; ToBeWrappedPvtKey, wrapMech,<br>
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;SecParam, &amp;WrappedKey, NULL);</i></small>&lt;/big&gt;</small></li>
  <li><small>&lt;big&gt;<small>&lt;big&gt;Transport/Store or do whatever with the Wrapped Key (WrappedKey.data, WrappedKey.len)&lt;/big&gt;</small>&lt;/big&gt;</small></li>
  <li><small>&lt;big&gt;<small>&lt;big&gt;Unwrapping.&lt;/big&gt;</small>&lt;/big&gt;</small>
    <ul>
      <li>Prepare the args for the unwrap function. Most of the args are illustrated above<br>
        <small><i>SECItem label; /* empty, doesn't need to be freed */<br>
        label.data = NULL; label.len = 0;</i></small><br>
        <i><small>SECItem *pubValue = NULL;<br>
        pubValue = /* ?? */;</small></i><br>
        <i><small>PRBool token = /* PR_TRUE or PR_FALSE depending on?? */<br>
        CK_MECHANISM_TYPE keyTypeMech = ??;<br>
        CK_KEY_TYPE keyType;<br>
        keyType = PK11_GetKeyType(keyTypeMech, 0);<br>
        CK_ATTRIBUTE_TYPE attribs[4];<br>
        int numAttribs;</small><br>
        <small>/* figure out which operations to enable for this key */<br>
        if( keyType == CKK_RSA ) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attribs[0] = CKA_SIGN;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attribs[1] = CKA_DECRYPT;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attribs[2] = CKA_SIGN_RECOVER;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attribs[3] = CKA_UNWRAP;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; numAttribs = 4;<br>
        } else if(keyType == CKK_DSA) {<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; attribs[0] = CKA_SIGN;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; numAttribs = 1;<br>
        }</small></i></li>
      <li><small>&lt;big&gt;Do the unwrap&lt;/big&gt;</small><br>
        <i><small>SECKEYPrivateKey *UnwrappedPvtKey =<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PK11_UnwrapPrivKey(slot, WrappingSymKey, wrapMech, SecParam, &amp;WrappedKey,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;label, &nbsp;pubValue, token, PR_TRUE /* sensitive */<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyType,&nbsp; attribs, numAttribs, NULL /*wincx*/);</small></i><br>
        </li>
    </ul>
  </li>
  <li>Clean up<br>
    <small><i>PK11_FreeSymKey(WrappingSymKey);</i></small><br>
    <small>&lt;big&gt;<small><i>if (SecParam) SECITEM_FreeItem(SecParam, PR_TRUE);</i></small>&lt;/big&gt;</small><br>
    <small>&lt;big&gt;<small><i>SECITEM_FreeItem(&amp;WrappedKey, PR_TRUE);</i></small>&lt;/big&gt;<br>
    <i>if (pubValue)&nbsp; SECITEM_FreeItem(pubValue, PR_TRUE);</i></small><br>
    <small><i>if (UnwrappedPvtKey) SECKEY_DestroyPrivateKey(UnwrappedPvtKey);</i></small><br>
    <small><i>if (ToBeWrappedPvtKey) SECKEY_DestroyPrivateKey(ToBeWrappedPvtKey);</i></small><br>
    <small><i>PK11_FreeSlot(slot);</i></small></li>
</ol>
<hr></div><h2 id="public_key_wrapping_private_key_unwrapping_of_a_symmetric_key_(pki_based_key_transport)"><a href="#public_key_wrapping_private_key_unwrapping_of_a_symmetric_key_(pki_based_key_transport)" title="Permalink to Public Key Wrapping &amp; Private Key Unwrapping of a Symmetric Key (PKI based key transport)">Public Key Wrapping &amp; Private Key Unwrapping of a Symmetric Key (PKI based key transport)</a></h2><div><ol>
  <li>Include headers<br>
    <small><i>#include "nss.h"<br>
    #include "pk11pub.h"</i></small></li>
  <li>Make sure NSS is initialized.</li>
  <li>Choose a&nbsp; Wrapping mechanism. See wrapMechanismList in security/nss/lib/pk11wrap/pk11slot.c and security/nss/lib/ssl/ssl3con.c for examples of wrapping mechanisms. Most of them are cipher mechanisms.<br>
    <small><i>CK_MECHANISM_TYPE wrapMech = CKM_DES3_ECB; </i>&lt;big&gt;(for example)&lt;/big&gt;</small></li>
  <li>Slot on which to do the operation<br>
    <small><i>PK11SlotInfo* slot = PK11_GetBestSlot(wrapMech, NULL); &nbsp; <b>OR</b><br>
    PK11SlotInfo* slot = PK11_GetInternalKeySlot(); /* always returns int slot, may not be optimal */</i></small><br>
    This should be the slot that is best suited for the wrapping. This may or may not be the slot that contains the public/private key or the slot that contains the Symmetric key.<br>
    <br>
    <small>&lt;big&gt;Regarding the choice of slot and wrapMech, if you know one, you can derive the other. You can get the best slot given a wrap mechanism (as shown above), or get the best wrap mechanism given a slot using:&lt;/big&gt;</small><br>
    <small><i>CK_MECHANISM_TYPE wrapMech = PK11_GetBestWrapMechanism(slot)</i></small></li>
  <li>Prepare the Wrapping Key
    <ul>
      <li><small><i>SECKeyPublicKey *WrappingPubKey</i></small></li>
    </ul>
  </li>
  <li>Prepare the To-be-Wrapped Key
    <ul>
      <li>If using a raw key<br>
        <small><i>/* turn the raw key into a SECItem */<br>
        SECItem keyItem;<br>
        keyItem.data = /* ptr to an array of key bytes */<br>
        keyItem.len = /* length of the array of key bytes */<br>
        <br>
        /* turn the SECItem into a key object */<br>
        PK11SymKey* ToBeWrappedSymKey = PK11_ImportSymKey(slot, wrapMech,,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;PK11_OriginUnwrap,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;CKA_WRAP,&nbsp; &amp;keyItem, NULL)</i></small>;</li>
      <li>If generating the key - see section <a href="#generate_a_symmetric_key">Generate a Symmetric Key</a></li>
    </ul>
  </li>
  <li>Allocate space for the wrapped key<br>
    <small><i>SECItem WrappedKey;<br>
    WrappedKey.len = SOME_LEN;<br>
    WrappedKey.data = allocate (SOME_LEN) bytes;</i></small></li>
  <li><small>&lt;big&gt;Do the Wrap&lt;/big&gt;</small>. Note that the WrappingPubKey and the ToBeWrappedSymKey must be on the slot where the wrap is going to happen. To move &nbsp;keys to the desired slot, see section <a href="#moving_a_key_from_one_slot_to_another">Moving a Key from one slot to another</a><br>
    <small>&lt;big&gt;<small><i>SECStatus s = PK11_PubWrapSymKey(wrapMech, WrappingPubKey,<br>
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ToBeWrappedSymKey, &amp;WrappedKey);</i></small>&lt;/big&gt;</small></li>
  <li><small>&lt;big&gt;<small>&lt;big&gt;Transport/Store or do whatever with the Wrapped Key (WrappedKey.data, WrappedKey.len)&lt;/big&gt;</small>&lt;/big&gt;</small></li>
  <li><small>&lt;big&gt;<small>&lt;big&gt;Unwrapping. &lt;/big&gt;</small>&lt;/big&gt;</small>
    <ul>
      <li>Prepare the args for the unwrap function. Most of the args are illustrated above<br>
        <i><small>SECKEYPrivateKey *UnWrappingPvtKey;<br>
        CK_MECHANISM_TYPE keyTypeMech = ??; </small></i></li>
      <li><small>&lt;big&gt;Do the unwrap&lt;/big&gt;<br>
        <i>PK11SymKey *UnwrappedSymKey =<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PK11_PubUnwrapSymKey(UnWrappingPvtKey, WrappedKey, keyTypeMech,<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i></small><small>&lt;big&gt;<small>&lt;big&gt;<small><i>CKA_UNWRAP, /* or CKA_DECRYPT? */<br>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</i></small>&lt;/big&gt;</small>&lt;/big&gt;</small><small>&lt;big&gt;<small>&lt;big&gt;<small><i>size_of_key_that_was_wrapped_bytes);</i></small>&lt;/big&gt;</small>&lt;/big&gt;</small></li>
    </ul>
  </li>
  <li>Clean up<br>
    <small><i>PK11_FreeSymKey(ToBeWrappedSymKey);</i></small><br>
    <small>&lt;big&gt;<small><i>SECITEM_FreeItem(&amp;WrappedKey, PR_TRUE);</i></small>&lt;/big&gt;<br>
    <i>if (WrappingPubKey) SECKEY_DestroyPublicKey(WrappingPubKey);</i></small><br>
    <small><i>if (UnwrappingPvtKey) SECKEY_DestroyPrivateKey(UnwrappingPvtKey);</i></small><br>
    <small><i>PK11_FreeSlot(slot);</i></small></li>
</ol>
<p>Also look at a <a href="../sample-code/sample1.html">sample program</a> that uses the above functions.</p>
<hr></div><h2 id="generate_a_symmetric_key_2"><a href="#generate_a_symmetric_key_2" title="Permalink to Generate a Symmetric Key">Generate a Symmetric Key</a></h2><div><p>Subsequent to the operation, the symmetric key may need to be transported/stored in wrapped or raw form. You can find a list of key generation mechanisms in security/nss/lib/softoken/pkcs11.c - grep for CKF_GENERATE. For some key gen mechanisms, the keysize is in bytes, and for some it is in bits.<br>
  &nbsp;</p>
<ol>
  <li><small>&lt;big&gt;Choose a key generation mechanism&lt;/big&gt;<br>
    <i>CK_MECHANISM_TYPE keygenMech = CKM_DES_KEY_GEN;</i></small> (for example)</li>
  <li><small>&lt;big&gt;Generate the key&lt;/big&gt;<br>
    <i>PK11SymKey* SymKey = PK11_KeyGen(slot, keygenMech, NULL, keysize, NULL);</i></small></li>
</ol>
<p><small>&lt;big&gt;You can also see an <a href="../sample-code/sample1.html">sample program</a> that does key generation.&lt;/big&gt;</small></p>
<h4 id="extract_the_raw_key_(this_should_not_normally_be_used._better_to_use_wrapping_instead._see_method1_and_method2_).">Extract the raw key (This should not normally be used. Better to use wrapping instead. See <a href="#symmetric_key_wrappingunwrapping_sym_key">method1</a> and <a href="#pki_wrap_symkey">method2</a> ).&nbsp;</h4>
<p><i><small>SECStatus rv = PK11_ExtractKeyValue(SymKey);<br>
  SECItem *keydata = PK11_GetKeyData(SymKey);</small></i></p>

<h4 id="generating_a_persistent_symmetric_key">Generating a persistent symmetric key</h4>
<p><small><i>SECItem keyid;<br>
  CK_MECHANISM_TYPE cipherMech = CKM_AES_CBC_PAD;<br>
  keyid.data = /* ptr to an array of bytes representing the id of the key to be generated */;<br>
  keyid.len = /* length of the array of bytes */;<br>
  /* keysize must be 0 for fixed key-length algorithms like DES... and appropriate value<br>
  &nbsp;* &nbsp;for non fixed-key-length algorithms */<br>
  PK11SymKey *key = PK11_TokenKeyGen(slot, cipherMech, 0, 32 /* keysize */,<br>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&amp;keyid, PR_TRUE, 0);</i></small><br>
  <br>
  <small><i>int keylen = PK11_GetKeyLength(key);<br>
  cipherMech = PK11_GetMechanism(key);</i></small><br>
  <br>
  <small><i>/* find the symmetric key in the database */<br>
  key = PK11_FindFixedKey(slot, cipherMech, &amp;keyid, 0);</i></small></p>



<hr></div><h2 id="moving_a_key_from_one_slot_to_another_2"><a href="#moving_a_key_from_one_slot_to_another_2" title="Permalink to Moving a Key from one slot to another">Moving a Key from one slot to another</a></h2><div><ul>
  <li>To move a Private key from one slot to another, wrap the private key on the origin slot and unwrap it into the destination slot. See section <a href="#symmetric_key_wrappingunwrapping_pvtkey">Symmetric Key Wrapping/Unwrapping of a Private Key</a></li>
  <li>To move a Symmetric key<br>
    <small><i>PK11SymKey *destSymKey = pk11_CopyToSlot(destslot, wrapMech, CKA_UNWRAP?, origSymKey);</i></small></li>
</ul>
<hr></div><h2 id="generate_an_rsa_key_pair"><a href="#generate_an_rsa_key_pair" title="Permalink to Generate an RSA Key Pair">Generate an RSA Key Pair</a></h2><div><p><i><small>PK11_GenerateKeyPair</small></i>&lt;big&gt;<small> is the function to use</small>&lt;/big&gt;. See a <a href="../sample-code/sample1.html">sample program</a> that uses this function.</p>

<hr></div><h2 id="<big>sign_verify_data<big>"><a href="#<big>sign_verify_data<big>" title="Permalink to <big>Sign &amp; Verify Data</big>"><small>&lt;big&gt;Sign &amp; Verify Data&lt;/big&gt;</small></a></h2><div><p><small><i>SECKEYPrivateKey *pvtkey;<br>
  SECItem signature;<br>
  SECItem data;<br>
  SECStatus s = PK11_Sign(pvtkey, &amp;signature, &amp;data);</i></small><br>
  <br>
  <small><i>SECKeyPublicKey *pubkey;</i></small><br>
  <small><i>SECStatus s = PK11_Verify(pubkey, &amp;signature, &amp;data, NULL);</i></small></p>

<hr></div><h2 id="misc_useful_functions"><a href="#misc_useful_functions" title="Permalink to Misc Useful Functions">Misc Useful Functions</a></h2><div><ol>
  <li>Get the best wrapping mechanism supported by a slot<br>
    <small><i>CK_MECHANISM_TYPE mech = PK11_GetBestWrapMechanism(PK11SlotInfo *slot);</i></small></li>
  <li><small>&lt;big&gt;Get the best slot for a certain mechanism&lt;/big&gt;</small><br>
    <small><i>PK11SlotInfo* slot = PK11_GetBestSlot(mechanism, NULL);</i></small></li>
  <li><small>&lt;big&gt;Get the best key length for a certain mechanism on a given slot&lt;/big&gt;</small><br>
    <small><i>int keylen = PK11_GetBestKeyLength(PK11SlotInfo *slot, mechanism);</i></small></li>
  <li>Get the key length of a symmetric key<br>
    <small><i>int keylen = PK11_GetKeyLength(PK11SymKey *symkey);</i></small></li>
  <li>Get the mechanism given a symmetric key<br>
    <small><i>CK_MECHANISM_TYPE mech = PK11_GetMechanism(PK11SymKey *key);</i></small><br>
    &nbsp;</li>
</ol>
<hr></div></article><aside class="metadata"><div class="metadata-content-container"><div id="on-github" class="on-github"><h4>Found a problem with this page?</h4><ul><li><a href="https://github.com/mdn/content/blob/main/files/en-us/mozilla/projects/nss/nss_tech_notes/nss_tech_note5/index.html" title="Folder: en-us/mozilla/projects/nss/nss_tech_notes/nss_tech_note5 (Opens in a new tab)" target="_blank" rel="noopener noreferrer">Source on <b>GitHub</b></a></li><li><a href="https://github.com/mdn/content/issues/new?body=MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FMozilla%2FProjects%2FNSS%2FNSS_Tech_Notes%2Fnss_tech_note5%0A%0A%23%23%23%23+What+information+was+incorrect%2C+unhelpful%2C+or+incomplete%3F%0A%0A%0A%23%23%23%23+Specific+section+or+headline%3F%0A%0A%0A%23%23%23%23+What+did+you+expect+to+see%3F%0A%0A%0A%23%23%23%23+Did+you+test+this%3F+If+so%2C+how%3F%0A%0A%0A%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EMDN+Content+page+report+details%3C%2Fsummary%3E%0A%0A*+Folder%3A+%60en-us%2Fmozilla%2Fprojects%2Fnss%2Fnss_tech_notes%2Fnss_tech_note5%60%0A*+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FMozilla%2FProjects%2FNSS%2FNSS_Tech_Notes%2Fnss_tech_note5%0A*+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fmozilla%2Fprojects%2Fnss%2Fnss_tech_notes%2Fnss_tech_note5%2Findex.html%0A*+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2F8c1ca6575872d0de37e76f859e8e535638322bb5%0A*+Document+last+modified%3A+2021-02-02T17%3A19%3A18.000Z%0A%0A%3C%2Fdetails%3E&amp;title=Issue+with+%22nss+tech+note5%22%3A+%28short+summary+here+please%29&amp;labels=Content%3AOther%2Cneeds-triage" title="This will take you to https://github.com/mdn/content to file a new issue" target="_blank" rel="noopener noreferrer">Report a problem with this content on <b>GitHub</b></a></li><li>Want to fix the problem yourself? See<!-- --> <a href="https://github.com/mdn/content/blob/main/README.md" target="_blank" rel="noopener noreferrer">our Contribution guide</a>.</li></ul></div><p class="last-modified-date"><b>Last modified:</b> <time datetime="2021-02-02T17:19:18.000Z">Feb 2, 2021</time>,<!-- --> <a href="/en-US/docs/Mozilla/Projects/NSS/NSS_Tech_Notes/nss_tech_note5/contributors.txt">by MDN contributors</a></p></div></aside></main></body></html>